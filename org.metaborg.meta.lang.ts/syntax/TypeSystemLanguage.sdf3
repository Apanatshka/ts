module TypeSystemLanguage

imports 
  common/Identifiers   
  common/Layout 
  terms/Terms
  
  Module
  Signatures
  TypeFunctions
  PP

context-free start-symbols Module

templates

  // TsModule.Module = <
  //   module <Id> 
  //     <TypeRules*; separator="\n\n">
  // >  

  ModuleSection.TypeRules = <
    type rules
    
      <TypeRule*; separator="\n\n">
    >

  TypeRule.TypeRuleUnCond = 
    <<PropPattern>>

  TypeRule.TypeRule = <
    <PropPattern>
    where <Formula>
    >

templates // formulas

  Formula = <<Prop>>

  Formula.Else = <
    <Formula> else error <Term> on <Term>
  > {left} 
  
  Formula.Not = <
    not <Formula>
  >
    
  Formula.Or = <
    <Formula> 
    or <Formula>
  > {assoc}
   
  Formula.And = <
    <Formula> 
    and <Formula>
  > {assoc}
  
  Formula.Label = <
    <LId> :: <Formula>
  >
  
  Formula = <(<Formula>)> {bracket}
  
context-free priorities

   Formula.Label > Formula.Not > Formula.Else > Formula.And > Formula.Or
   
lexical syntax

  SubTypeOp = "<" Id? ":" 
   
templates // propositions
  
  Prop.True         = <true>
  Prop.False        = <false>
  Prop.HasType      = <<Term> : <Pattern>>
  Prop.SubType      = [[Term] [SubTypeOp] [Term]]
  Prop.StoreSubType = [store [Term] [SubTypeOp] [Term]]
  Prop.Has          = <<Term> has <Id> <Pattern>>  
  Prop.Eq           = [[Term] == [Term]] 
  Prop.Match        = [[Term] => [Pattern]]
  
templates // proposition patterns
   
  PropPattern.HasTypePat = <<Pattern+; separator=" + "> : <Term>>
  PropPattern.SubTypePat = [[Pattern] [SubTypeOp] [Pattern]]
  PropPattern.HasPat     = <<Pattern+; separator=" + "> has <Id> <Term>>
  PropPattern.IsWF       = <<Pattern+; separator=" + "> :->
     
templates // term operators

  Term.DefOf = <definition of <Term>>
  
  Term.Union = <<Term> union <Term>>
  Term.Choice  = [[Term] or [Term]]

templates // keywords

  Id = <where> {reject}
