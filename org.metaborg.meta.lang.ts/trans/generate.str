module generate

imports
	
	include/TypeSystemLanguage
	pp
  
rules 
 
  to-stratego(|project-path, modname) :
    Module(name, section*) ->
    $[module [modname]
    
      [import]
      [import*]
      rules
        [rule*]
        
      rules // projections
        [projection*]
    ]
    where rule* := <collect(rule-to-stratego)> section*
        ; projection* := <bagof-Projections>
        ; import*     := <collect(imports-to-stratego)> section*
        ; if <collect-all(?ImportWildcard(<string-ends-with(|"/types")>))> section* => [] then
        import := 
              $[imports
              	  
                  lib/runtime/nabl/-
                  lib/runtime/task/-
                  lib/runtime/types/-
                  lib/runtime/properties/-
               ]
      else
        import := ""
      end 
 
rules
  
  imports-to-stratego:
    Imports(import*) -> 
    $[imports
      
        [<map(import-to-stratego)> import*]]
    
  import-to-stratego:
    Import(t) -> 
    $[[t]
    ]
    
  import-to-stratego:
    ImportWildcard(t) -> 
    $[[t]/-
    ]
        
rules
	
	task-dependencies =
		collect(?Label(<![<id>]>, _) <+ ?Match(_, <pattern-vars>)); concat; make-set
  pattern-vars =
    collect(?Var(<id>))
			     
rules // conditional rule
  
  rule-to-stratego :
    TypeRule(HasPat(pat, kind, trm), form) -> ${
      create-{kind}-task(|ctx) :
        {<term-to-stratego>pat} -> <task-create-id(|ctx, [{deps}])> {<term-to-stratego>trm}
        where {s}
    } 
    where (_, s) := <formula-to-stratego> form
        ; deps := <task-dependencies; separate-by(|", "); concat-strings> form
          
  // todo: target for WF rules
  rule-to-stratego :
    TypeRule(IsWF(pat), form) -> $[
      nabl-constraint(|ctx) :
        [<term-to-stratego>pat] -> <fail>
        where [s]
    ]
    where (_, s) := <formula-to-stratego> form
        ; deps := <task-dependencies; separate-by(|", "); concat-strings> form

  rule-to-stratego :
    TypeRule(SubTypePat(pat1, op, pat2), form) -> $[
      create-subtype-task(|ctx) :
        ("[op]", [<term-to-stratego>pat1], [<term-to-stratego>pat2]) -> [dep]
        where [s]
    ]
    where (dep, s) := <formula-to-stratego> form
        ; deps := <task-dependencies; separate-by(|", "); concat-strings> form
                    
rules // formula
      
  formula-to-stratego :
    True() -> ("", $[id])
    
  formula-to-stratego :
    And(form1, form2) -> 
      (t2, $[[s1];
             [s2]])
    where (t1, s1) := <formula-to-stratego> form1
        ; (t2, s2) := <formula-to-stratego> form2

  formula-to-stratego :
    Label(l, Or(form1, form2)) -> 
      (l, $[[s1];
            [s2];
            [l] := <new-task(|ctx)> Choice($[$[t1],[t2]$]$)])
    where (t1, s1) := <formula-to-stratego> form1
        ; (t2, s2) := <formula-to-stratego> form2
        //; t3 := <newname> "task"
        
  formula-to-stratego :
    Else(form, msg, target) -> 
      (t, $[[s];
            <task-create-error-on-failure(|ctx, [t], [<term-to-stratego>msg])> [<term-to-stratego>target]])
    where (t, s) := <formula-to-stratego> form
            
  formula-to-stratego :
    Label(l, Has(VarRef(x), attr, Var(t))) -> 
      (t, $[[t] := <[attr]-task(|ctx)> [x]])
      
  formula-to-stratego :
    Label(l, Has(DefOf(trm), op, Var(t))) -> 
      (t, $[[t] := <[op]-lookup(|ctx)> [<term-to-stratego>trm]])
                              
  formula-to-stratego :
    Label(l, SubType(trm1, op, trm2)) ->
      (l, $[[l] := <create-subtype-task(|ctx)>("[op]", [<term-to-stratego>trm1], [<term-to-stratego>trm2])])
 
  formula-to-stratego :
    Label(l, Eq(trm1, trm2)) -> 
      (l, $[[l] := <type-match(|ctx, [<term-to-stratego>trm2])> [<term-to-stratego>trm1]])

  formula-to-stratego :
    Match(x, pat) -> (<Hd> ys, strat)
    where
      ys := <pattern-vars> pat;
      strat := <map(mk-projection(|x, pat)); separate-by(|";\n")> ys
      
  formula-to-stratego :
    Label(l, Match(x, pat)) -> (l, $[[l] := <new-task(|ctx)> Rewrite("[rl]", [<term-to-stratego>x])])
    where
      [] := <pattern-vars> pat;
      rl := <newname> "match";
      r := $[
        task-rewrite :
          ("[rl]", x@[<term-to-stratego>pat]) -> x
      ];
      rules( Projections :+ _ -> r)
      
  formula-to-stratego :
    Label(l, Match(Combine(trm1, trm2), Var(x))) -> 
      (l, $[[x] := <new-task(|ctx)> Combine($[$[<term-to-stratego>trm1], [<term-to-stratego>trm2]$]$)])
            
   mk-projection(|x, pat) :
     y -> $[[y] := <new-task(|ctx)> Rewrite("[rl]", [<term-to-stratego>x])]
     where rl := <newname> "proj"
         ; r := $[
             task-rewrite :
               ("[rl]", [<term-to-stratego>pat]) -> [y]
           ]
         ; rules( Projections :+ _ -> r )

rules // term
  
  term-to-stratego :
    Wld() -> "_"
    
  term-to-stratego :
    Var(x) -> x
    
  term-to-stratego :
    VarRef(x) -> x

  term-to-stratego :
    ListVar(x) -> x
    
  term-to-stratego :
    ListVarRef(x) -> x
        
  term-to-stratego :
    Int(i) -> i
    
  term-to-stratego :
    Real(r) -> r
    
  term-to-stratego :
    Str(s) -> s

  term-to-stratego :
    Char(s) -> s
        
  term-to-stratego :
    As(v, p) -> $[[<term-to-stratego>v]@[<term-to-stratego>p]]
    
  term-to-stratego :
    Op(cns, t*) -> $[[cns]([<map(term-to-stratego); separate-by(|", ")> t*])]
    
  term-to-stratego :
    OpQ(cns, t*) -> $["[cns]"([<map(term-to-stratego); separate-by(|", ")> t*])]
            
  term-to-stratego :
    Tuple(t*) -> $[([<map(term-to-stratego); separate-by(|", ")> t*])]

  term-to-stratego :
    List(t*) -> $<[<<map(term-to-stratego); separate-by(|", ")> t*>]>
    
  term-to-stratego :
    ListTail(t*, t) -> $<[<<map(term-to-stratego); separate-by(|", ")> t*> | <<term-to-stratego>t>]>
  
  // term-to-stratego :
  //   DefOf(ns, trm) -> $[<type-lookup(|ctx)> [<term-to-stratego> trm]]


            

        

    
