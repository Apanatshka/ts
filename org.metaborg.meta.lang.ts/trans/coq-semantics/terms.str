module coq-semantics/terms

imports
  include/TypeSystemLanguage
  coq-semantics/-
  lib/Coq/signatures/-

rules // Formulas
  prop-to-coq(|i):
    Else(e, _, _) -> <prop-to-coq(|i)> e
    
  prop-to-coq(|i):
    And(e1, e2) -> ([e1'*, e2'*], <union> (b-e1*, b-e2*), ie2)
    where
      (e1'*, b-e1*, ie1) := <prop-to-coq(|i)> e1
    ; (e2'*, b-e2*, ie2) := <prop-to-coq(|ie1)> e2
  
  prop-to-coq(|i):
    Not(_) -> <debug(!"Not rules not supported: "); fail>
  
  prop-to-coq(|i):
    Or(_,_) -> <debug(!"Or rules not supported: "); fail>
    
rules // Props

  prop-to-coq(|i):
    True() -> ([], [], i)
  
  prop-to-coq(|i):
    HasType(e1, e2) -> ([T|[has_type term_e1' term_e2']|], <union> (b-e1*, b-e2*), ie2)
    where not(DefOf(_) := e1)
    where
      (term_e1', b-e1*, ie1) := <term-to-coq(|i)> e1
    ; (term_e2', b-e2*, ie2) := <term-to-coq(|ie1)> e2
  
  prop-to-coq(|i):
    HasType(DefOf(VarRef(ident_x)), e2) -> ([T|[lookup t def_of ident_x VariableNS ident_kx ident_ty]|], bind*, i')
    where
      ident_kx               := $[k[<Fst>i]]
    ; (ident_ty, b-e2*, ie2) := <term-to-coq(|<incI> i)> e2
    ; i'                     := <addX(|ident_x, ident_kx)> ie2
    ; bind*                  := <union> (<map(!Bind(<id>))> [ident_kx, ident_x], b-e2*)
  
  prop-to-coq(|i):
    Eq(e1, e2) -> ([T|[eq term_e1' term_e2']|], <union> (b-e1*, b-e2*), ie2)
    where
      (term_e1', b-e1*, ie1) := <term-to-coq(|i)> e1
    ; (term_e2', b-e2*, ie2) := <term-to-coq(|ie1)> e2

rules // Terms
  
  term-to-coq(|i):
    Op(name', bind*) -> (T|[Co ident_name term_param ident_k]|, bound*, <incI> i)
    where
      ident_name := $[[name']C]
    ; bind'*     := <map(?Var(<id>) <+ ?VarRef(<id>))> bind*
    ; term_param := <map(parameter(|i)); !List(<id>)> bind'*
    ; ident_k    := $[k[<Fst> i]]
    ; bound*     := <conc> (<map(!Bind(<id>))> bind'*, [Bind(ident_k)])
  
  term-to-coq(|i):
    VarRef(x) -> (x, [Bind(x)], i)

  term-to-coq(|i):
    Var(x) -> (x, [Bind(x)], i)

rules // Fold rules
  
  parameter(|i): ident_x -> r
    where
      r := <lookup < (?ident_k; !T|[Id ident_x ident_k]|) + !ident_x> (ident_x, <Snd> i)
    
rules
  incI: (i, l) -> (<inc> i, l)
  addX(|x, k): (i, l*) -> (i, [(x, k) | l*])
