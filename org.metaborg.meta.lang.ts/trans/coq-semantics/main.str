module coq-semantics/main

imports
  libstratego-gpp
  coq-semantics/-
  lib/runtime/index/-
  lib/runtime/nabl/-
  lib/runtime/properties/-
  lib/runtime/task/-
  names
  lib/editor-common.generated
  include/TypeSystemLanguage
  lib/Coq/pp/-
  lib/Coq/-
  lib/Coq/signatures/-

rules
  
  generate-coq:
    (selected, position, ast, path, project-path) -> (filename, result)
    with
      task-setup(|project-path)
    ; filename := "src-gen/verification/types.v"
    ; coq-file := <strip-annos; module-to-coq(|"types")> ast
    with
       result := <parenthesize-Coq; prettyprintCoq-CoqFile; box2text-string(|100)> coq-file
    <+ <bottomup(try(not(is-string) ; not(is-list) ; not(prettyprintCoq-example) ; debug(!"cannot pp ")))> coq-file
    ;  result := ""

rules
  
  module-to-coq(|filename):
  	Module(name, rule*) -> <build-module(|filename)> ind_decl
  		where definition* := <filter(?TypeRules(<id>)); concat; filter(type-rules-to-coq); concat> rule*
  		    ; term_eq := "term_eq" // Workaround because I don't want to unquote this below.
  		    ; decls   := ListDeclBar([ definition*, D|[HT_eq e ty1 ty2 (hty1: has_type e ty1) (tyeq: term_eq ty1 ty2) : has_type e ty2]| ]) 
  		    ; ind_decl  := S|[Inductive has_type : term -> term -> Prop := decls.]|

rules // Type rules
  type-rules-to-coq:
    TypeRule(rule, cond) -> <map(type-rule-to-coq(|cond'*))> pat*
    where
      (cond'*, bound*, i) := <prop-to-coq(|(0, []))> cond
    ; pat*                := <prop-pats-to-coq(|bound*, i)> rule
  
  type-rules-to-coq:
  	TypeRuleUnCond(rule) -> <type-rules-to-coq> TypeRule(rule, True())
  	
  type-rule-to-coq(|cond*):
    (ident_name, bind*, final-type) -> D|[ident_name binds : term_type]|
    where
      term_type  := <foldr(!final-type, fold-type)> cond*
    ; binds      := OptBinders(bind*)

rules // PropPattern
  
  prop-pats-to-coq(|bound*, i):
    HasTypePat(pat*, ty) -> <map(prop-pat-to-coq(|bind'*, i', ty'))> pat*
    where
      (ty' , b-ty*, i') := <term-to-coq(|i)> ty
    ; bind'*            := <union> (b-ty*, bound*)
      
  prop-pats-to-coq(|bound*, i):
    HasPat(pat*, "type", ty) -> <prop-pats-to-coq(|bound*, i)> HasTypePat(pat*, ty)
    
  prop-pats-to-coq(|bound*, i):
    IsWF(_) -> <debug(!":- rules are not supported: "); fail>
    
  prop-pat-to-coq(|bound*, i, term_ty):
    pat@(Op(name, _)) -> ($[[name]C_ht], <union> (bound*, b*), ty')
    where
      (term_pat', b*, _) := <term-to-coq(|i)> pat
    ; ty'                := T|[has_type term_pat' term_ty]|

  prop-pat-to-coq(|bound*, i, ty):
    As(_, op) -> <prop-pat-to-coq(|bound*, i, ty)> op

rules // Fold rules
  
  fold-type: // Composes parts of a type
    (term_x, term_y) -> T|[term_x -> term_y]|
