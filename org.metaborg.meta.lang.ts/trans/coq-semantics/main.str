module coq-semantics/main

imports
  libstratego-gpp
  coq-semantics/-
  lib/runtime/index/-
  lib/runtime/nabl/-
  lib/runtime/properties/-
  lib/runtime/task/-
  names
  lib/editor-common.generated
  include/TypeSystemLanguage

rules
  
  generate-coq:
    (selected, position, ast, path, project-path) -> (filename, result)
    with
      task-setup(|project-path)
    ; filename := <guarantee-extension(|"v")> path
    ; coq-file := <strip-annos; module-to-coq> ast
    with
       result := <parenthesize-Coq; prettyprint-CoqFile; box2text-string(|100)> coq-file
    <+ <bottomup(try(not(is-string) ; not(is-list) ; not(prettyprint-example) ; debug(!"cannot pp ")))> coq-file
    ;  result := ""

rules
  
  module-to-coq:
  	Module(name, rule*) -> Sent([IND_HT(final-def*)])
  		where definition* := <filter(?TypeRules(<id>)); concat; filter(type-rules-to-coq); concat> rule*
  		    ; final-def*  := [definition*, TYPE_EQUALITY()] 

rules // Type rules
  type-rules-to-coq:
    TypeRule(rule, cond) -> <map(type-rule-to-coq(|cond'*))> pat*
    where
      (cond'*, bound*, i) := <prop-to-coq(|(0, []))> cond
    ; pat*                := <prop-pats-to-coq(|bound*, i)> rule
  
  type-rules-to-coq:
  	TypeRuleUnCond(rule) -> <type-rules-to-coq> TypeRule(rule, True())
  	
  type-rule-to-coq(|cond*):
    (name, bind*, final-type) -> HT_DEF(name, bind*, type)
    where
      type                      := <foldr(!final-type, fold-type)> cond*

rules // PropPattern
  
  prop-pats-to-coq(|bound*, i):
    HasTypePat(pat*, ty) -> <map(prop-pat-to-coq(|bind'*, i', ty'))> pat*
    where
      (ty' , b-ty*, i') := <term-to-coq(|i)> ty
    ; bind'*            := <union> (b-ty*, bound*)
      
  prop-pats-to-coq(|bound*, i):
    HasPat(pat*, "type", ty) -> <prop-pats-to-coq(|bound*, i)> HasTypePat(pat*, ty)
    
  prop-pats-to-coq(|bound*, i):
    IsWF(_) -> <debug(!":- rules not supported: "); fail>
    
  prop-pat-to-coq(|bound*, i, ty):
    pat@(Op(name, _)) -> ($[[name]C_ht], <union> (bound*, b*), ty')
    where
      (pat', b*, _) := <term-to-coq(|i)> pat
    ; ty'           := HT_APP_TYPE(pat', ty)

rules // Fold rules
  
  fold-type: // Composes parts of a type
    (x, y) -> Product(x, y)

overlays

  IND_HT(terms) =
		Inductive(
		  Ind(
		    [ Induc(
		        "has_type"
		      , [Binds(["C"], Ref("Context"))]
		      , Type(
		          Product(Ref("term"), Product(Ref("term"), Sort(Prop())))
		        )
		      , ListDeclBar(terms)
		      )
		    ]
		  )
		)

  HT_DEF(name, binds, type) =
		ConsDecl(
		  name
		, binds
		, Type(type)
    )
  
  HT_APP_TYPE(e1, e2) =
	  APPLY2(
	    Apply(Ref("has_type"), Ref("C"))
	    , e1
	    , e2
	  )
	  
	CONS(hd, tl) = APPLY2(Ref("cons"), hd, tl)
	
	APPLY2(op, e1, e2) = Apply(Apply(op, e1), e2)
	APPLY4(op, e1, e2, e3, e4) = APPLY2(APPLY2(op, e1, e2), e3, e4)
	
	TYPE_EQUALITY =
	  ConsDecl(
      "HT_eq"
      , [ Bind("e")
        , Bind("ty1")
        , Bind("ty2")
        , Binds(
            ["hty1"]
            , HT_APP_TYPE(Ref("e"), Ref("ty1"))
            )
        , Binds(
            ["tyeq"]
          , Apply(Apply(Ref("term_eq"), Ref("ty1")), Ref("ty2"))
          )
        ]
      , Type(
          HT_APP_TYPE(Ref("e"), Ref("ty2"))
        )
      )