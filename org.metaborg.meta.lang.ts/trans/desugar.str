module desugar

imports
  
  include/TypeSystemLanguage
	label

strategies // desugaring
  
  desugar-all = 
    innermost(desugar)

rules // unconditional rules
  
  desugar :
    TypeRuleUnCond(prop) -> TypeRule(prop, True())
      
rules // rule splitting
   
  desugar :
  	TypeRules(t*) -> TypeRules(<mapconcat(split-rule <+ MkSingleton); not(?t*)> t*)
  
  split-rule :
    TypeRuleUnCond(pat) -> <split-patterns; map(!TypeRuleUnCond(<id>))> pat

  split-rule :
    TypeRule(pat, form) -> <split-patterns; map(!TypeRule(<id>, form))> pat
    
  split-patterns : 
  	HasTypePat(pat*, trm) -> <map(!HasTypePat(<id>, trm))> pat*
  	
  split-patterns : 
  	HasPat(pat*, kind, trm) -> <map(!HasPat(<id>, kind, trm))> pat*
  	
  split-patterns : 
  	IsWF(pat*) -> <map(!IsWF(<id>))> pat*
   
rules // normalization 	
  	
  desugar :
    And(x, And(y, z)) -> And(And(x, y), z) 
    
  desugar :
    And(True(), p) -> p
    
  desugar :
    And(p, True()) -> p 
    
  desugar :
    Or(p, False()) -> p
  
  desugar :
    Or(False(), p) -> p
    
rules // propositions
      
  desugar :
    HasType(trm, pat) -> Has(trm, "type", pat)
  
  desugar :
    HasTypePat(pat, trm) -> HasPat(pat, "type", trm)
    
  desugar :
    Has(trm, kind, pat) -> And(Has(trm, kind, Var(x)), Match(VarRef(x), pat))
    where <not(?Var(_))> pat; x := <newname> "x"
    
  desugar :
    TypeRule(HasPat(pat, kind, trm), form) -> 
    TypeRule(HasPat(pat, kind, VarRef(x)), And(form, Match(trm, Var(x))))
    where <not(?VarRef(_))> trm; x := <newname> "x"

rules // unstar list variables
      
  desugar :
    ListVar(x) -> Var(<unstar>x)
    
  desugar :
    ListVarRef(x) -> VarRef(<unstar>x) 
    
  unstar = 
    explode-string; map(try(\ 42 -> 95 \)); implode-string
   
    
